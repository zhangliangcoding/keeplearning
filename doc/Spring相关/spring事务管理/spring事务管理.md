### Spring事务管理

#### 事务

针对一批事件操作，要么全部执行成功，要么全部失败，保证数据的一致性和完整性

#### 四个特征

- 原子性 原子操作，要么全部成功要么全部失败
- 隔离性 多个事务之间的数据没有干扰
- 持久性 事务一旦执行完成，就是持久的，无论系统发生什么异常，生效数据不会受到影响
- 一致性 事务一旦完成，无论成功还是失败，系统都是保持一致的，而不会部分失败部分成功

#### Spring事务隔离级别

> 当多个事务并发执行时，经常会出现多个事务操作相同的数据，这样就会照成一些问题
>
> 脏读 - 一个事务读取了另一个事务未提交的数据
>
> 不可重复度 - 一个事务在多次读取同一数据是，返回不一样，原因是别的事务对此数据有做修改
>
> 幻读 - 一个事务在读取多条数据，紧接着另一个事务插入了一些数据
>
> *不可重复度强调修改，幻读强调添加和删除*

- READ_UNCOMMITED 最低隔离级别，读未提交，造成脏读
- READ_COMMITED 读提交，造成幻读，不可重复度
- REPEATABLE_READ 可重复读，解决的不可重复度和脏读，还是会造成幻读
- READ_SERIALISABLE 序列化读，解决所有问题，但是效率低

#### Spring事务传播行为

> 当事务方法被另一个事务方法调用时，必须制定事务传播行为，入A方法内调用B方法

- PROPAGATION_REQUIRED

  A操作有事务，则B操作使用事务；如果A操作没有事务，则B事务新建一个事务。最常见的。

- PROPAGATION_SUPPORT

  A操作有事务，则B操作使用事务；A操作没有事务，B操作非事务运行

- PROPAGATION_MANDATORY

  A操作有事务，则B操作使用事务；A操作没有事务，B操作抛出异常

- PROPAGATION_NESTED

  A存在事务B事务声明为NESTED嵌套事务，可以认为B为A的一个子事务，如果A没有异常，B有异常，B执行回滚，A不会回滚。如果A事务失败回滚，B无论失败成功，都会回滚

- PROPAGATION_REQUIRES_NEW

  A操作有事务，将A事务挂起，B创建一个新的事务运行；A无事务，则B创建一个新的事务

- PROPAGATION_NOT_SUPPORT

  A操作有事务，将事务挂起，B非事务运行；A操作无事务，B以非事务运行

- PROPAGATION_NEVER

  A操作有事务，B操作抛出异常；A操作无事务，B非事务方式运行


#### Spring怎么实现事务管理

##### 顶层接口

- PlatformTransactionManager 事务管理核心接口
- TransactionDefination 事务定义接口，定义事务的隔离级别和传播行为类型等
- TransactionStatus 事务状态接口，记录事务的状态