###Java内存模型JMM
在java语言中，通过共享内存模型来实现多线程的信息交换和数据同步。在了解java内存模型之前先了解一下Java内存结构，即运行时的数据区域。
####Java内存结构
- 程序计数器

  程序计数器记录当前程序执行的程序的内存地址。java是多线程的，每个线程都有独立的程序计数器，各个线程的计数器互不干扰。类似ThreadLocal

- Java栈

  与线程关联一起，每个线程对应一个栈，在每个栈中，包含多个栈帧。没执行一个方法，就会创建一个栈帧放入栈中，每个栈帧包含一些局部变量、操作栈和方法返回值等信息。每操作完一个方法，对应的栈帧从栈中删除。在HotSpot虚拟机中，可以通过设置-Xss参数来设置栈的大小，栈的大小决定了函数执行的可达深度。在栈中会有两种异常，第一种是当虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。第二种是如果线程请求的栈的深度大于虚拟机所允许的深度，就会报StackOverflowError异常；

- 堆

  堆是Java中管理的内存中最大的一块区域，被所有java线程共享。堆是存储对象的地方，所有的对象实例及数组都要在堆上分配。一般堆又分为老年代和新生代，新生代继续分为eden控件和from survivor 和to survivor控件

- 方法区

  方法区保存类的基本信息，类中的静态变量及类中定义为final类型的常量。方法区也是堆中的一部分，也叫做永久代，可通过-XX:permSize来设置初始值，-XX:MaxPerSize设置最大值

- 常量池

  属于方法区的一部分。常量池中存储了字符串、final变量值、类名和方法名常量

- 本地方法栈

  主要为native方法服务

#### 主内存和工作内存

- 主内存

  主内存是线程公有的，所有变量都保存在之内存中

- 工作内存

  线程私有，工作内存中保存主内存变量的副本

#### 三个原则

- 原子性

  要么执行要么不执行，但是long和double类型的变量在32为的jvm中不是原子操作，有可能数据被破坏

- 可见性

  一个线程修改了一个变量后，其他线程能够感知到这个变量的修改。

- 有序性

#### 重排序

在现在多核系统中，为提高性能，编译器和处理器会对指令进行重排序，大体分为以下几种

- 编译器重排序

  编译器在不改变单线程语义的情况下，对程序进行重新排序执行

- 指令级并行重排序

  多核处理器并行执行，如果指令间没有依赖关系会进行指令重新排序

- 内存重排序

  处理器使用缓存和读写缓冲区，每个处理器有单独的内存，并使用读写缓冲区，往主内存刷新数据，看上去程序执行是乱序的

针对编译器重排，编译器针对某种特定的类型，禁止重排序。针对系统级别的重排序(指令级和内存系统级别)，编译器会添加内存屏障来避免重排序。JMM的内存屏障分为以下四种：StoreStore，LoadLoad，StoreLoad和LoadStore



#### Happens-Before原则

happens-before来阐述操作之间的内存可见性，如果一个操作的执行结果对另一个操作可见，这两个操作就必须存在happens-before关系。两个操作可以是同一个线程，可以是不同线程。A happen-before B 并不能说明A 先于B执行，只说明A操作的结果对B可见

- 程序顺序规则

  一个线程中，一个操作happens-before于该线程任意的后续操作

- 监视器锁规则

  同一个监视器锁，一个锁操作happen-before于下一个锁的操作

- volatile变量规则

  对于一个volatile变量的写，happen-before后续的读操作

- 传递性

  A happen-before B ，B happen-before C 则 A happen-before C

#### as-if-serial语义

不管怎么排序不能影响程序最终的执行结果。编译器、处理器都要遵守



#### volatile

##### volatile读写语义

- volatile写

  当写一个volatile变量时，把修改后的值刷新到主内存

- volatile读

  当读一个volatile变量时，工作内存的volatile变量失效，从主内存中读取最新变量

##### volatile内存语义实现

为实现volatile内存语义，编译器再生成字节码时，插入了内存屏障（上面说的四种内存屏障）来避免处理器重排，具体实现策略如下：

- 在每个写操作前插入storestore屏障
- 在每个写操作后面插入storeload屏障
- 在每个读操作前面插入loadload屏障
- 在每个读操作后面插入loadstore屏障