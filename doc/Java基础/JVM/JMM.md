###Java内存模型JMM
在java语言中，通过共享内存模型来实现多线程的信息交换和数据同步。在了解java内存模型之前先了解一下Java内存结构，即运行时的数据区域。
####Java内存结构
- 程序计数器

  程序计数器记录当前程序执行的程序的内存地址。java是多线程的，每个线程都有独立的程序计数器，各个线程的计数器互不干扰。类似ThreadLocal

- Java栈

  与线程关联一起，每个线程对应一个栈，在每个栈中，包含多个栈帧。没执行一个方法，就会创建一个栈帧放入栈中，每个栈帧包含一些局部变量、操作栈和方法返回值等信息。每操作完一个方法，对应的栈帧从栈中删除。在HotSpot虚拟机中，可以通过设置-Xss参数来设置栈的大小，栈的大小决定了函数执行的可达深度。在栈中会有两种异常，第一种是当虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。第二种是如果线程请求的栈的深度大于虚拟机所允许的深度，就会报StackOverflowError异常；

- 堆

  堆是Java中管理的内存中最大的一块区域，被所有java线程共享。堆是存储对象的地方，所有的对象实例及数组都要在堆上分配。一般堆又分为老年代和新生代，新生代继续分为eden控件和from survivor 和to survivor控件

- 方法区

  方法区保存类的基本信息，类中的静态变量及类中定义为final类型的常量。方法区也是堆中的一部分，也叫做永久代，可通过-XX:permSize来设置初始值，-XX:MaxPerSize设置最大值

- 常量池

  属于方法区的一部分。常量池中存储了字符串、final变量值、类名和方法名常量

- 本地方法栈

  主要为native方法服务

#### 主内存和工作内存

- 主内存

  主内存是线程公有的，所有变量都保存在之内存中

- 工作内存，线程私有，工作内存中保存主内存变量的副本

#### 三个原则

- 原子性

  要么执行要么不执行，但是long和double类型的变量在32为的jvm中不是原子操作，有可能数据被破坏

- 可见性

  一个线程修改了一个变量后，其他线程能够感知到这个变量的修改。

- 有序性

#### Happens-Before原则

